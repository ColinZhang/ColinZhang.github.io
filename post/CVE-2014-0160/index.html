<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en-us">
<head>
  <link href="http://gmpg.org/xfn/11" rel="profile">
  <meta http-equiv="content-type" content="text/html; charset=utf-8">

  
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">

  <title> Why heart bleeds &middot; fz84 </title>

  
  <link rel="stylesheet" href="http://bl4ck5un.github.io//css/poole.css">
  <link rel="stylesheet" href="http://bl4ck5un.github.io//css/syntax.css">
  <link rel="stylesheet" href="http://bl4ck5un.github.io//css/hyde.css">
  <link rel="stylesheet" href="http://fonts.googleapis.com/css?family=PT+Sans:400,400italic,700|Abril+Fatface">

    
  <link rel="stylesheet" href="https://yandex.st/highlightjs/8.0/styles/solarized_light.min.css">
<script src="https://yandex.st/highlightjs/8.0/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad();</script>

  
  <link rel="stylesheet" href="http://bl4ck5un.github.io//font-awesome/css/font-awesome.min.css">
  <link rel="apple-touch-icon-precomposed" sizes="144x144" href="/apple-touch-icon-144-precomposed.png">
  <link rel="shortcut icon" href="/favicon.ico">

  
  <link href="" rel="alternate" type="application/rss+xml" title="fz84" />
</head>

<body>

<div class="sidebar">
  <div class="container sidebar-sticky">
    <div class="sidebar-about">
      <h1>fz84</h1>
      <p class="lead">
       Read, write and do research in systems and security 
      </p>
    </div>

    <ul class="sidebar-nav">
      <li><a href="/">Home</a> </li>
      
        <li><a href="/post/"> Blogs </a></li>
      
    </ul>

    <p>&copy; 2015. All rights reserved. </p>
  </div>
</div>


    <div class="content container">
<div class="post">
  <h1>Why heart bleeds</h1>
  <span class="post-date">Thu, Apr 10, 2014</span>
      

<p>This blog investigated the recently introduced Heartbeat mechanism in TLS, which unfortunately leads to the widely spread <strong>HeartBleed</strong> vulnerability, aka CVE-2014-0160.</p>

<h2 id="description-from-nvd:ce6f2c75e20b8ec034404887a73bf817">Description from NVD</h2>

<p>The (1) <code>TLS</code> and (2) <code>DTLS</code> implementations in <code>OpenSSL 1.0.1</code> before <code>1.0.1g</code> do not properly handle Heartbeat Extension packets, which allows remote attackers to obtain sensitive information from process memory via crafted packets that trigger a buffer over-read, as demonstrated by reading private keys, related to <code>d1_both.c</code> and <code>t1_lib.c</code>, aka the Heartbleed bug.</p>

<p>To <a href="https://web.nvd.nist.gov/view/vuln/detail?vulnId=CVE-2014-0160">NVD</a></p>

<h2 id="heartbeat-extension:ce6f2c75e20b8ec034404887a73bf817">Heartbeat Extension</h2>

<p>The <strong>Heartbeat Extension</strong> is a new feature augmented for the Transport Layer Security (TLS) and Datagram Transport Layer Security (DTLS) protocols. Basically the Heartbeat Extension is designed to provide a faster and light-weight keeping-alive mechanism, and DTLS protocol can use it to perform path MTU (PMTU) discovery as well.</p>

<p>Generally speaking, the Heartbeat Extension works in a quite simple way, in which the client sends out a <code>HeartbeatRequest</code> message and the server respond it with an exact copy of payload to indicate that <em>I&rsquo;m not only alive but conscious.</em> Of course all messages changed in this routine is on the top of TLS layer. (Precisely speaking, the Heartbeat protocol is a new protocol running on top of the Record Layer.)</p>

<p>To <a href="https://tools.ietf.org/html/rfc6520">RFC6520</a></p>

<h2 id="messages:ce6f2c75e20b8ec034404887a73bf817">Messages</h2>

<p>According to RFC6520, the HeartBeat protocol message consists of their type, attached payload and padding.</p>

<pre><code class="language-c">struct {
    HeartbeatMessageType type;
    uint16 payload_length;
    opaque payload[HeartbeatMessage.payload_length];
    opaque padding[padding_length];
} HeartbeatMessage;
</code></pre>

<p>Though the description in RFC is fairly clear and concise, I&rsquo;d like to summarize several important and tangent facts for understanding CVE-2014-0160,</p>

<ul>
<li>According to the RFC, The length of the <code>type</code> field is 1 byte, and the length of the <code>payload_length</code> is 2.</li>
<li>Padding can not be too large: The length of a HeartbeatMessage is <code>TLSPlaintext.length</code> for TLS and <code>DTLSPlaintext.length</code> for DTLS. (decided through peer negotiation, default is 2^14 Bytes(octets))</li>
<li>Nor can padding be too tiny: The <code>padding_length</code> MUST be at least 16.</li>
</ul>

<h2 id="hits:ce6f2c75e20b8ec034404887a73bf817">Hits</h2>

<p>See what will happen if we send this crafted HeartbeatRequest messages to the vulnerable server,</p>

<p>See <a href="http://en.wikipedia.org/wiki/Transport_Layer_Security">Wikipedia</a></p>

<pre><code class="language-c">18 03 02 00 03 01 40 00

18   : Content type::Heartbeat
0302 : Major Version=3, Minor Version=2, indicates TLS 1.1 
0003 : Length = 3
01   : TLS1_HB_REQUEST
4000 : 0x4000=2^14=16384, indicates 64-byte length of payload
</code></pre>

<p>Request process happens in <code>tls1_process_heartbeat</code> function.</p>

<pre><code class="language-c">int
tls1_process_heartbeat(SSL *s)
{
  unsigned char *p = &amp;s-&gt;s3-&gt;rrec.data[0], *pl;   // (1) p points to packet
  unsigned short hbtype;
  unsigned int payload;
  unsigned int padding = 16; /* Use minimum padding */

  /* Read type and payload length first */
  hbtype = *p++;        // (2) p gets advanced to point to `payload_length`
  n2s(p, payload);      // (3) payload = n2s(*p), p+=2
  pl = p;               // (4) p and pl points to payload

  if (s-&gt;msg_callback)
    s-&gt;msg_callback(0, s-&gt;version, TLS1_RT_HEARTBEAT,
      &amp;s-&gt;s3-&gt;rrec.data[0], s-&gt;s3-&gt;rrec.length,
      s, s-&gt;msg_callback_arg);

  if (hbtype == TLS1_HB_REQUEST)
    {
    unsigned char *buffer, *bp;
    int r;

    buffer = OPENSSL_malloc(1 + 2 + payload + padding);
    bp = buffer;      // (1) bp points to buffer

    /* Enter response type, length and copy payload */
    *bp++ = TLS1_HB_RESPONSE;    // (2) 1st byte: TYPE
    s2n(payload, bp);            // (3) 2-3 byte: payload_length
    memcpy(bp, pl, payload);     // (*) payload Bytes of secret copied **
    bp += payload;
    /* Random padding */
    RAND_pseudo_bytes(bp, padding);

    //... all secrets get sent to client ...
}
</code></pre>

<h2 id="fix:ce6f2c75e20b8ec034404887a73bf817">Fix</h2>

<pre><code class="language-diff">diff --git a/ssl/t1_lib.c b/ssl/t1_lib.c
index b82fada..bddffd9 100644 (file)
--- a/ssl/t1_lib.c
+++ b/ssl/t1_lib.c
@@ -2588,16 +2588,20 @@ tls1_process_heartbeat(SSL *s)
        unsigned int payload;
        unsigned int padding = 16; /* Use minimum padding */

-       /* Read type and payload length first */
-       hbtype = *p++;
-       n2s(p, payload);
-       pl = p;
-
        if (s-&gt;msg_callback)
                s-&gt;msg_callback(0, s-&gt;version, TLS1_RT_HEARTBEAT,
                        &amp;s-&gt;s3-&gt;rrec.data[0], s-&gt;s3-&gt;rrec.length,
                        s, s-&gt;msg_callback_arg);

+       /* Read type and payload length first */
+       if (1 + 2 + 16 &gt; s-&gt;s3-&gt;rrec.length)
+               return 0; /* silently discard */
+       hbtype = *p++;
+       n2s(p, payload);
+       if (1 + 2 + payload + 16 &gt; s-&gt;s3-&gt;rrec.length)
+               return 0; /* silently discard per RFC 6520 sec. 4 */
+       pl = p;
+
        if (hbtype == TLS1_HB_REQUEST)
                {
                unsigned char *buffer, *bp;
</code></pre>

</div>
</div>

  </body>
</html>
