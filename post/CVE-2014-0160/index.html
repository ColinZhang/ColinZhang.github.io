<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en-us">
<head>
  <link href="http://gmpg.org/xfn/11" rel="profile">
  <meta http-equiv="content-type" content="text/html; charset=utf-8">

  
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">

  
      <title> Why heart bleeds &middot; Fan@CU </title>
  

  
  <link rel="stylesheet" href="http://fanzy.me/css/screen.css">

    
  



<link href="/css/themes/github.css" rel="stylesheet" type="text/css">
<script src="/js/rainbow-custom.min.js"></script>
<script src="/js/rainbow.linenumbers.min.js"></script>

<link rel="stylesheet" href="/css/code.css">


  
  <link rel="stylesheet" href="http://fanzy.me/font-awesome/css/font-awesome.min.css">

  
  <link href="" rel="alternate" type="application/rss+xml" title="Fan@CU" />
</head>

<body>

<div class="sidebar">
    
    <div class="sidebar-about">
      <h1 id="site-title">Fan@CU</h1>
      
    </div>

    <ul id="sidebar-nav">
      <li><a href="/" class="sidebar-nav-item">Home</a> </li>
      
        <li><a href="/post/" class="sidebar-nav-item"> Blogs </a></li>
      
        <li><a href="/CV/" class="sidebar-nav-item"> CV </a></li>
      
    </ul>

    <p id="sidebar-copyright">
    &copy; 2015. All rights reserved. </p>
  
</div>


<div class="content container">
<div class="post">
  <h1 class="title">Why heart bleeds</h1>
  
  <span class="post-date">Thu, Apr 10, 2014</span>
  

      

<p>It&rsquo;s not rare that the critical security infrastructure on which we heavily reply sometimes is broken, in one way or another. This blog investigated the <code>Heartbeat</code> mechanism in TLS protocol and how it leads to the widely spread <strong>HeartBleed</strong> vulnerability, aka CVE-2014-0160 in <code>OpenSSL 1.0.1</code>.</p>

<h2 id="description-from-nvd:ce6f2c75e20b8ec034404887a73bf817">Description from NVD</h2>

<p>The (1) <code>TLS</code> and (2) <code>DTLS</code> implementations in <code>OpenSSL 1.0.1</code> before <code>1.0.1g</code> do not properly handle Heartbeat Extension packets, which allows remote attackers to obtain sensitive information from process memory via crafted packets that trigger a buffer over-read, as demonstrated by reading private keys, related to <code>d1_both.c</code> and <code>t1_lib.c</code>, aka the Heartbleed bug.</p>

<p>To <a href="https://web.nvd.nist.gov/view/vuln/detail?vulnId=CVE-2014-0160">NVD</a></p>

<h2 id="heartbeat-extension:ce6f2c75e20b8ec034404887a73bf817">Heartbeat Extension</h2>

<p>First let&rsquo;s have a look at the Heartbeat Extension. The <strong>Heartbeat Extension</strong> is a pretty new extension to the Transport Layer Security (TLS) and Datagram Transport Layer Security (DTLS) protocols. Essentially the Heartbeat Extension is designed to provide a faster and light-weight keeping-alive mechanism, and DTLS protocol can use it to perform path MTU (PMTU) discovery as well.</p>

<p>Generally speaking, the Heartbeat Extension works in a quite simple way. Clients peroidcally send <code>HeartbeatRequest</code> messages (including a random chosen payload) to server and the server respond with the exact copy of that payload. If the server&rsquo;s response matches with the original message, the clients can make sure that that *the server is not only alive but responsive. Of course all the messages exchanged during this routine is on top of TLS layer. (Precisely speaking, the Heartbeat protocol is a new protocol running on top of the Record Layer.)For details please refer to <a href="https://tools.ietf.org/html/rfc6520">RFC6520</a>.</p>

<h2 id="messages:ce6f2c75e20b8ec034404887a73bf817">Messages</h2>

<p>A natural question we&rsquo;re gonna ask is how can this simple mechanism go wrong? To answer this question, we need to know some nitty-gritty. First, data structure. According to RFC6520, a HeartBeat message consists of <code>type</code>, <code>length</code>, attached <code>payload</code> and <code>padding</code>.</p>

<pre><code class="language-c">struct {
    HeartbeatMessageType type;
    uint16 payload_length;
    opaque payload[HeartbeatMessage.payload_length];
    opaque padding[padding_length];
} HeartbeatMessage;
</code></pre>

<p>Though the description in RFC is fairly clear and concise, I&rsquo;d like to summarize several important and tangent facts for better understanding of CVE-2014-0160,</p>

<ul>
<li>The length of the <code>type</code> field is 1 byte, and the length of the <code>payload_length</code> is 2.</li>
<li>A HeartbeatMessage must be shorter than <code>TLSPlaintext.length</code>(TLS) or <code>DTLSPlaintext.length</code>(DTLS). (decided through peer negotiation, default is 2^14 Bytes</li>
<li>The <code>padding_length</code> must be at least 16.</li>
</ul>

<h2 id="scene-of-the-accident:ce6f2c75e20b8ec034404887a73bf817">Scene of the accident</h2>

<p>So here is the vulnerable code in OpenSSL 1.0.1. Let&rsquo;s check step by step to see what would happen when server receives the following message:<code>&quot;\x18\x03\x02\x00\x03\x01\x40\x00&quot;</code>. A few legends,</p>

<ul>
<li><code>18</code>   : Content type::Heartbeat</li>
<li><code>0302</code> : Major Version=3, Minor Version=2, indicates TLS 1.1</li>
<li><code>0003</code> : Length = 3</li>
<li><code>01</code>   : TLS1_HB_REQUEST</li>
<li><code>4000</code> : 0x4000=2^14=16384, indicates 64-byte payload</li>
</ul>

<p>Apparently, this packet is totally invalid, in that it claimed a non-existent 64 bytes payload. This is not hard to check at all, simply looking at the <code>length</code> of the whole packet and the <code>padding_length</code> is enough, because other parts is of fixed-length. However, OpenSSL didn&rsquo;t do this simple check. In other words, the above packet, though apparently invalid, will be treated as normal in the following function.</p>

<pre><code class="language-c">int
tls1_process_heartbeat(SSL *s)
{
  unsigned char *p = &amp;s-&gt;s3-&gt;rrec.data[0], *pl;   // (1) p points to packet
  unsigned short hbtype;
  unsigned int payload;
  unsigned int padding = 16; /* Use minimum padding */

  /* Read type and payload length first */
  hbtype = *p++;        // (2) p gets advanced to point to `payload_length`
  n2s(p, payload);      // (3) payload = n2s(*p), p+=2
  pl = p;               // (4) p and pl points to payload

  if (s-&gt;msg_callback)
    s-&gt;msg_callback(0, s-&gt;version, TLS1_RT_HEARTBEAT,
      &amp;s-&gt;s3-&gt;rrec.data[0], s-&gt;s3-&gt;rrec.length,
      s, s-&gt;msg_callback_arg);

  if (hbtype == TLS1_HB_REQUEST)
    {
    unsigned char *buffer, *bp;
    int r;

    buffer = OPENSSL_malloc(1 + 2 + payload + padding);
    bp = buffer;      // (1) bp points to buffer

    /* Enter response type, length and copy payload */
    *bp++ = TLS1_HB_RESPONSE;    // (2) 1st byte: TYPE
    s2n(payload, bp);            // (3) 2-3 byte: payload_length
    memcpy(bp, pl, payload);     // (*) payload Bytes of secret copied **
    bp += payload;
    /* Random padding */
    RAND_pseudo_bytes(bp, padding);

    //... all secrets get sent to client ...
}

//fetched from ssl/ssl_locl.h
//  n2s(c, s)
//  s = c[0] || c[1] (|| stands for concatanation)
//  c = c + 2
# define n2s(c,s)  ((s=(((unsigned int)(c[0]))&lt;&lt; 8)| \
              (((unsigned int)(c[1])))),c+=2)
</code></pre>

<p>Suppose we call <code>tls1_process_heartbeat</code> with the crafted packet <code>&quot;\x18\x03\x02\x00\x03\x01\x40\x00&quot;</code>. What would happen is:</p>

<ol>
<li><code>p</code> points to the beginning of HeartBeat message, i.e. the byte <code>&quot;\x01&quot;</code></li>
<li><code>hbtype := TLS1_HB_REQUEST</code> and <code>p</code> points to <code>payload_length</code>, i.e. <code>&quot;\x40\x00&quot;</code></li>
<li><code>payload := 0x4000</code>, <code>p</code> nows points to somewhere outside of the packet (note that packet has already ended, there is no payload at all!)</li>
<li><code>memcpy(bp, pl, payload)</code> actually copied 64 bytes memory from <code>pl</code>, somewhere in stack, to the response packet that users that see in clear.</li>
</ol>

<h2 id="fix-and-conclusion:ce6f2c75e20b8ec034404887a73bf817">Fix and Conclusion</h2>

<p>As we saw before, it&rsquo;s fairly straightforward to fix this bug &ndash; just check the length! It turned out basically just one line of C code can save the world. How surprising it is! Even though TLS is elegantly designed on board, even though the RFC is well written and carefully proof read, a single line of code can screw up everything. This bug reminds me of a sentence in Practical Cryptography:.</p>

<p>Official patch is attached for completeness.</p>

<pre><code class="language-diff">diff --git a/ssl/t1_lib.c b/ssl/t1_lib.c
index b82fada..bddffd9 100644 (file)
--- a/ssl/t1_lib.c
+++ b/ssl/t1_lib.c
@@ -2588,16 +2588,20 @@ tls1_process_heartbeat(SSL *s)
        unsigned int payload;
        unsigned int padding = 16; /* Use minimum padding */

-       /* Read type and payload length first */
-       hbtype = *p++;
-       n2s(p, payload);
-       pl = p;
-
        if (s-&gt;msg_callback)
                s-&gt;msg_callback(0, s-&gt;version, TLS1_RT_HEARTBEAT,
                        &amp;s-&gt;s3-&gt;rrec.data[0], s-&gt;s3-&gt;rrec.length,
                        s, s-&gt;msg_callback_arg);

+       /* Read type and payload length first */
+       if (1 + 2 + 16 &gt; s-&gt;s3-&gt;rrec.length)
+               return 0; /* silently discard */
+       hbtype = *p++;
+       n2s(p, payload);
+       if (1 + 2 + payload + 16 &gt; s-&gt;s3-&gt;rrec.length)
+               return 0; /* silently discard per RFC 6520 sec. 4 */
+       pl = p;
+
        if (hbtype == TLS1_HB_REQUEST)
                {
                unsigned char *buffer, *bp;
</code></pre>

</div>

  
      <div id="disqus_thread"></div>
<script type="text/javascript">

(function() {
    
    
    if (window.location.hostname == "localhost")
        return;

    var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
    var disqus_shortname = 'FZ84';
    dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
})();
</script>
<noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<a href="http://disqus.com/" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
  

</div>

<footer>
  <div> Copyright &copy Fan 2014-2015</div>
  <div> Last updated at Thu Oct  8 19:10:56 EDT 2015 </div>
</footer>

</body>
</html>
