<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Exploit | Colin's Key]]></title>
  <link href="http://CMade.github.io/blog/categories/exploit/atom.xml" rel="self"/>
  <link href="http://CMade.github.io/"/>
  <updated>2014-04-11T11:37:27+08:00</updated>
  <id>http://CMade.github.io/</id>
  <author>
    <name><![CDATA[Fan Zhang]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[CVE-2014-0160]]></title>
    <link href="http://CMade.github.io/blog/2014/04/10/cve-2014-0160/"/>
    <updated>2014-04-10T17:16:30+08:00</updated>
    <id>http://CMade.github.io/blog/2014/04/10/cve-2014-0160</id>
    <content type="html"><![CDATA[<h2>Description from NVD</h2>

<p>The (1) <code>TLS</code> and (2) <code>DTLS</code> implementations in <code>OpenSSL 1.0.1</code> before <code>1.0.1g</code> do not properly handle Heartbeat Extension packets, which allows remote attackers to obtain sensitive information from process memory via crafted packets that trigger a buffer over-read, as demonstrated by reading private keys, related to <code>d1_both.c</code> and <code>t1_lib.c</code>, aka the Heartbleed bug.</p>

<p><a href="https://web.nvd.nist.gov/view/vuln/detail?vulnId=CVE-2014-0160">To NVD</a></p>

<h2>Heartbeat Extension</h2>

<p>The <strong>Heartbeat Extension</strong> is a new feature augmented for the Transport Layer Security (TLS) and Datagram Transport Layer Security (DTLS) protocols. Basically the Heartbeat Extension is designed to provide a faster and light-weight keeping-alive mechanism, and DTLS protocol can use it to perform path MTU (PMTU) discovery as well.</p>

<p>Generally speaking, the Heartbeat Extension works in a quite simple way, in which the client sends out a <code>HeartbeatRequest</code> message and the server respond it with an exact copy of payload to indicate that <em>I&rsquo;m not only alive but conscious.</em> Of course all messages changed in this routine is on the top of TLS layer. (Presisely speaking, the Heartbeat protocol is a new protocol running on top of the Record Layer.)</p>

<p><a href="https://tools.ietf.org/html/rfc6520">To RFC6520</a></p>

<h2>Messages</h2>

<p>According to RFC6520, the HB protocol message consists of their type, attached payload and padding.</p>

<p>```c
struct {</p>

<pre><code>HeartbeatMessageType type;
uint16 payload_length;
opaque payload[HeartbeatMessage.payload_length];
opaque padding[padding_length];
</code></pre>

<p>} HeartbeatMessage;
```</p>

<p>Though the description in RFC is fairly clear and concise, I&rsquo;d like to summarize several important and tangent facts for understanding CVE-2014-0160,</p>

<ul>
<li>According to the RFC, The length of the <code>type</code> field is 1 byte, and the length of the <code>payload_length</code> is 2.</li>
<li>Padding can not be too large: The length of a HeartbeatMessage is <code>TLSPlaintext.length</code> for TLS and <code>DTLSPlaintext.length</code> for DTLS. (decided through peer negotiation, default is 2<sup>14</sup> Bytes(octets))</li>
<li>Nor can padding be too tiny: The <code>padding_length</code> MUST be at least 16.</li>
</ul>


<h2>Hits</h2>

<p>See what will happen if we send this crafted HeartbeatRequest messages to the vulnerable server,</p>

<p><a href="http://en.wikipedia.org/wiki/Transport_Layer_Security">Wikipedia</a></p>

<p>```text
18 03 02 00 03 01 40 00</p>

<p>18   : Content type::Heartbeat
0302 : Major Version=3, Minor Version=2, indicates TLS 1.1
0003 : Length = 3
01   : TLS1_HB_REQUEST
4000 : 0x4000=2<sup>14</sup>=16384, indicates 64-byte length of payload</p>

<p>```</p>

<p>```c       <br/>
int
tls1_process_heartbeat(SSL *s)</p>

<pre><code>{
unsigned char *p = &amp;s-&gt;s3-&gt;rrec.data[0], *pl;   // (1) p points to packet
unsigned short hbtype;
unsigned int payload;
unsigned int padding = 16; /* Use minimum padding */

/* Read type and payload length first */
hbtype = *p++;        // (2) p gets advanced to point to `payload_length`
n2s(p, payload);      // (3) payload = n2s(*p), p+=2
pl = p;               // (4) p and pl points to payload

if (s-&gt;msg_callback)
    s-&gt;msg_callback(0, s-&gt;version, TLS1_RT_HEARTBEAT,
        &amp;s-&gt;s3-&gt;rrec.data[0], s-&gt;s3-&gt;rrec.length,
        s, s-&gt;msg_callback_arg);

if (hbtype == TLS1_HB_REQUEST)
    {
    unsigned char *buffer, *bp;
    int r;

    buffer = OPENSSL_malloc(1 + 2 + payload + padding);
    bp = buffer;      // (1) bp points to buffer

    /* Enter response type, length and copy payload */
    *bp++ = TLS1_HB_RESPONSE;    // (2) 1st byte: TYPE
    s2n(payload, bp);            // (3) 2-3 byte: payload_length
    memcpy(bp, pl, payload);     // (*) payload Bytes of secret copied **
    bp += payload;
    /* Random padding */
    RAND_pseudo_bytes(bp, padding);

    //... all secrets get sent to client ...
}
</code></pre>

<p>```</p>

<h2>Fix</h2>

<p>```diff
diff &mdash;git a/ssl/t1_lib.c b/ssl/t1_lib.c
index b82fada..bddffd9 100644 (file)
&mdash;&ndash; a/ssl/t1_lib.c
+++ b/ssl/t1_lib.c
@@ -2588,16 +2588,20 @@ tls1_process_heartbeat(SSL *s)</p>

<pre><code>    unsigned int payload;
    unsigned int padding = 16; /* Use minimum padding */
</code></pre>

<ul>
<li><pre><code>/* Read type and payload length first */
</code></pre></li>
<li><pre><code>hbtype = *p++;
</code></pre></li>
<li><pre><code>n2s(p, payload);
</code></pre>

<h2>&ndash;       pl = p;</h2>

<pre><code>if (s-&gt;msg_callback)
        s-&gt;msg_callback(0, s-&gt;version, TLS1_RT_HEARTBEAT,
                &amp;s-&gt;s3-&gt;rrec.data[0], s-&gt;s3-&gt;rrec.length,
                s, s-&gt;msg_callback_arg);
</code></pre></li>
<li><pre><code>/* Read type and payload length first */
</code></pre></li>
<li><pre><code>if (1 + 2 + 16 &gt; s-&gt;s3-&gt;rrec.length)
</code></pre></li>
<li><pre><code>        return 0; /* silently discard */
</code></pre></li>
<li><pre><code>hbtype = *p++;
</code></pre></li>
<li><pre><code>n2s(p, payload);
</code></pre></li>
<li><pre><code>if (1 + 2 + payload + 16 &gt; s-&gt;s3-&gt;rrec.length)
</code></pre></li>
<li><pre><code>        return 0; /* silently discard per RFC 6520 sec. 4 */
</code></pre></li>
<li><pre><code>pl = p;
</code></pre>

<p>+
    if (hbtype == TLS1_HB_REQUEST)
            {
            unsigned char <em>buffer, </em>bp;
```</p></li>
</ul>

]]></content>
  </entry>
  
</feed>
