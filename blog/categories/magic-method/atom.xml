<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Magic Method | Colin's Key]]></title>
  <link href="http://colins-key.herokuapp.com/blog/categories/magic-method/atom.xml" rel="self"/>
  <link href="http://colins-key.herokuapp.com/"/>
  <updated>2014-04-10T21:00:06+08:00</updated>
  <id>http://colins-key.herokuapp.com/</id>
  <author>
    <name><![CDATA[Fan Zhang]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Python: Magic Methods]]></title>
    <link href="http://colins-key.herokuapp.com/blog/2014/03/15/all-about-OOP-in-Python-Part-II/"/>
    <updated>2014-03-15T22:00:00+08:00</updated>
    <id>http://colins-key.herokuapp.com/blog/2014/03/15/all-about-OOP-in-Python-Part-II</id>
    <content type="html"><![CDATA[<p>This post is second part of my <strong>Python OOP</strong> serials, talking about <em>comon magic methods</em> in Python.</p>

<h2>Index and slice: <code>__getitem__</code> and <code>__setitem__</code></h2>

<p><code>__getitem__</code>: After a class defines this method, index operation on its instance will invoke <code>__getitem__</code>. That is, <code>X[i]</code> will be process as <code>X.__getitem__(i)</code> by Python (Further, as <code>class.__getitem__(X, i)__</code>).</p>

<h3>capture slicing</h3>

<p>Besides index, slicing operation also invokes <code>__getitem__</code>. Formally, that is the way how built-in types to process slicing.</p>

<p>``` python</p>

<blockquote><blockquote><blockquote><p>L = [5, 6, 7, 8, 9]
L[2:4]
[7, 8]
```</p></blockquote></blockquote></blockquote>

<p>What realling happens behind the scene is,</p>

<p><code>python
L[slice(2, 4)] # 1
__getitem__(L, (slice(2, 4, None)) # 2
</code></p>

<h2>Iteration by indexing</h2>

<p><code>For</code> loop invokes <code>__getitem__</code> each time a iteration, with an automatic increasing <em>index</em>. Therefore, the situation is: any object that can response to index operation is able to respond iteration, in the similar way.</p>

<p>Actually, many other operations will trigger `<strong>getitem</strong> as well, many of which are quite intuitive &mdash; they all have a sense of looping over a sequence, such as:</p>

<p>```python</p>

<blockquote><blockquote><blockquote><p>&lsquo;p&rsquo; in X
[ c for c in X ]
map(str.upper, X)
(a, b, c, d) = X # sequence assignment
&lsquo;&rsquo;.join(X)
```</p></blockquote></blockquote></blockquote>

<p>The context where these operations happen is called <strong>interation environment</strong>.</p>

<h2>Interation: <code>__iter__</code> and <code>__next___</code></h2>

<p>Although <code>__getitem__</code> is a effective way to implement iteration, Python would perfer to try <code>__iter__</code> first, and then <code>__getitem__</code> if the former fails to exist.</p>

<p>Technically speaking, <code>__iter__</code> method should return a iterator object, which provides a <code>__next__</code> method to access next object of the iteration sequence. Python keeps invoking <code>__next__</code> method until <code>StopIteration</code> exception raises.</p>

<h2>Membership: <code>__contains__</code>, <code>__iter__</code> and <code>__getitem__</code></h2>

<p>Note that <em>operation overriding happens at multiple leaels</em>, which means in order to fulfill a certain objective, class can choose to provide either a specific and dedicate method or a second-class but more general plan B.</p>

<p>For example, membership operation can be implemented as anyone of <code>___getitem__</code>, <code>__iter__</code> and <code>__contains__</code>. But the priority is in reverse order: <code>__getitem__</code> can works, but <code>__contains__</code> is more suitable and dedicate.</p>

<h2>Attribute: <code>__getattr__</code> and <code>__setattr__</code></h2>

<ul>
<li><code>__getattr__</code>, <code>X.undefined</code></li>
<li><code>__getattribute__</code>, all <code>X.attr</code></li>
<li><code>__setattr__</code>, <code>X.attr = val</code></li>
</ul>


<p>Note that: any assignment to <code>self.attr</code> in <code>__setattr__</code> will cause dead loop and ending in a crash. Correct way is to manipulate attributes via <code>__dict__</code>.</p>

<p>Other attribution management tools to be cover later:</p>

<ul>
<li><code>__getattribute__</code></li>
<li><code>Property</code> built-in function</li>
<li>Descriptor protocol and <code>__get__</code>, <code>__set___</code></li>
</ul>


<h3>Simulate privacy: part I</h3>

<p>Python didnt provide a <code>private</code> statement, which means a class cannot hold its own private data immune from outside modification. Thanks to <code>__setattr__</code>, however, we can sitimulate this behavior by overwriting <code>__setattr__</code>.</p>

<h2><code>__repr__</code> and <code>__str__</code></h2>

<h2>Right side and Round side addition</h2>

<h2><code>__call__</code></h2>

<p>When a instance gets invoked, <code>__call__</code> method will be invoked. <code>__call__</code> provides effective way to implement so called <em>bound method</em>. Actually, <code>__calll__</code> might be the best way to store state information in Python, because <code>__call__</code> allows us to attach inner information to a callable object.</p>

<h2>Comparision: <code>__lt__</code>, <code>__gt__</code> and others</h2>

<h2><code>__bool__</code> and <code>__len__</code></h2>

<h2>descructor: <code>__del__</code></h2>
]]></content>
  </entry>
  
</feed>
